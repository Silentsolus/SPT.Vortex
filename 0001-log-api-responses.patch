From 0123456789abcdef0123456789abcdef01234567 Mon Sep 17 00:00:00 2001
From: Alex <alex@example.com>
Date: Sun, 1 Feb 2026 12:00:00 +0000
Subject: [PATCH] ForgeApiService: Log API response bodies at Debug (truncated)

Add debug-level logging of API response bodies (truncated to avoid huge
logs) to several places in `ForgeApiService` where we read JSON response
bodies. This helps capture real Forge API responses for creating fixtures
and debugging matching/asset selection.

Also add a small unit test to assert the debug message is emitted.

---
 Services/ForgeApiService.cs | 78 ++++++++++++++++++++++++++++++++++++++++++
 tests/ForgeApiService.Logging.Tests.cs | 98 ++++++++++++++++++++++++++++++++++
 2 files changed, 176 insertions(+)
 create mode 100644 tests/ForgeApiService.Logging.Tests.cs

diff --git a/Services/ForgeApiService.cs b/Services/ForgeApiService.cs
index e69de29..f00ba11 100644
--- a/Services/ForgeApiService.cs
+++ b/Services/ForgeApiService.cs
@@
 using System.Text.Json;
 using System.Text.RegularExpressions;
 using CheckMods.Configuration;
+using Microsoft.Extensions.Logging;
 using CheckMods.Models;
 using CheckMods.Services.Interfaces;
 using Microsoft.Extensions.Logging;
@@
 public partial class ForgeApiService(
     HttpClient httpClient,
     IRateLimitService rateLimitService,
     IApiKeyProvider apiKeyProvider,
-    IOptions<ForgeApiOptions> options,
-    ILogger<ForgeApiService> logger
+    IOptions<ForgeApiOptions> options,
+    ILogger<ForgeApiService> logger
 ) : IForgeApiService
 {
+    // Helper to truncate large response bodies when logging
+    private static string TruncateForLog(string s, int max = 32_000)
+    {
+        if (s is null) return string.Empty;
+        return s.Length <= max ? s : s.Substring(0, max) + "... (truncated)";
+    }
+
+    // Safe wrapper to read the response body and log it (Debug, truncated).
+    private async Task<string> GetJsonResponseStringAsync(HttpResponseMessage response, string url, CancellationToken cancellationToken)
+    {
+        var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
+
+        // Log the response body at Debug level (truncated to avoid excessively large logs)
+        try
+        {
+            logger.LogDebug("API Response: {Url}: {Body}", url, TruncateForLog(jsonContent));
+        }
+        catch (Exception ex)
+        {
+            // Protect production flow from logging errors
+            logger.LogDebug(ex, "Failed to log API response for {Url}", url);
+        }
+
+        return jsonContent;
+    }
+
@@
-            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
-            var apiResponse = JsonSerializer.Deserialize<ModSearchApiResponse>(jsonContent, _jsonOptions);
+            var jsonContent = await GetJsonResponseStringAsync(response, url, cancellationToken);
+            var apiResponse = JsonSerializer.Deserialize<ModSearchApiResponse>(jsonContent, _jsonOptions);
@@
-            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
-            var apiResponse = JsonSerializer.Deserialize<ModUpdatesApiResponse>(jsonContent, _jsonOptions);
+            var jsonContent = await GetJsonResponseStringAsync(response, url, cancellationToken);
+            var apiResponse = JsonSerializer.Deserialize<ModUpdatesApiResponse>(jsonContent, _jsonOptions);
@@
-            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
-            var apiResponse = JsonSerializer.Deserialize<SptVersionApiResponse>(jsonContent, _jsonOptions);
+            var jsonContent = await GetJsonResponseStringAsync(response, url, cancellationToken);
+            var apiResponse = JsonSerializer.Deserialize<SptVersionApiResponse>(jsonContent, _jsonOptions);
@@
-            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
-            var apiResponse = JsonSerializer.Deserialize<ModDependenciesApiResponse>(jsonContent, _jsonOptions);
+            var jsonContent = await GetJsonResponseStringAsync(response, url, cancellationToken);
+            var apiResponse = JsonSerializer.Deserialize<ModDependenciesApiResponse>(jsonContent, _jsonOptions);
@@
-            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
-            var authResponse = JsonSerializer.Deserialize<AuthAbilitiesResponse>(jsonContent, _jsonOptions);
+            var jsonContent = await GetJsonResponseStringAsync(response, url, cancellationToken);
+            var authResponse = JsonSerializer.Deserialize<AuthAbilitiesResponse>(jsonContent, _jsonOptions);
diff --git a/tests/ForgeApiService.Logging.Tests.cs b/tests/ForgeApiService.Logging.Tests.cs
new file mode 100644
index 0000000..f00ba11
--- /dev/null
+++ b/tests/ForgeApiService.Logging.Tests.cs
@@
+using System.Net;
+using System.Net.Http;
+using System.Threading.Tasks;
+using Microsoft.Extensions.Logging;
+using Xunit;
+
+namespace CheckMods.Tests
+{
+    public class ForgeApiServiceLoggingTests
+    {
+        [Fact]
+        public async Task GetJsonResponseStringAsync_LogsResponse_DebugLevel()
+        {
+            // Arrange - simple test HttpClient returning JSON
+            var handler = new DelegatingHandlerStub(new HttpResponseMessage(HttpStatusCode.OK)
+            {
+                Content = new StringContent("{\"ok\":true}")
+            });
+
+            var httpClient = new HttpClient(handler);
+            var logger = new TestLogger<CheckMods.Services.ForgeApiService>();
+            var service = new CheckMods.Services.ForgeApiService(httpClient, logger);
+
+            // Act
+            var result = await service.GetAllSptVersionsAsync("https://example.invalid/api/spt/versions?sort=-version&per_page=15");
+
+            // Assert - test logger captured the debug message
+            Assert.Contains(logger.Entries, e => e.LogLevel == LogLevel.Debug && e.Message.Contains("API Response"));
+        }
+    }
+
+    // Very small test logger to capture entries
+    internal class TestLogger<T> : ILogger<T>
+    {
+        public System.Collections.Generic.List<(LogLevel LogLevel, string Message)> Entries { get; } = new();
+
+        IDisposable ILogger.BeginScope<TState>(TState state) => null!;
+        bool ILogger.IsEnabled(LogLevel logLevel) => true;
+
+        void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, System.Exception exception, System.Func<TState, System.Exception, string> formatter)
+        {
+            Entries.Add((logLevel, formatter(state, exception)));
+        }
+    }
+
+    // Minimal delegating handler stub
+    internal class DelegatingHandlerStub : DelegatingHandler
+    {
+        private readonly HttpResponseMessage _response;
+        public DelegatingHandlerStub(HttpResponseMessage response)
+        {
+            _response = response;
+        }
+
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)
+        {
+            return Task.FromResult(_response);
+        }
+    }
+}
+
-- 
2.34.1
